import stdlib/Base/Assert;

assert "id" (id 5) "toEqual" 5;
assert "composition (°)" (((\x -> x * x) ° (\x -> x + 1)) 5) "toEqual" 36;
assert "const" (const 5 2) "toEqual" 5;
assert "not on Booleans" (not True) "toEqual" False;
assert "not on 0" (not 0) "toEqual" True;
assert "not on (1::10)" (all not (1::10)) "toEqual" False;
assert "eq" (5 == 5) "toEqual" True;
assert "eq" (-1 == 3) "toEqual" False;
assert "toBool" (toBool 3) "toEqual" True;
assert "toBool" (toBool 0) "toEqual" False;
assert "flip" (flip (<) 4 3) "toEqual" True;
assert "interpolated strings" (@"x${show 5} ${['a','b','c']} ${"test"}") "toEqual" "x5.0 abc test";
assert "is" (5 `is` "Num") "toBeTrue";
assert "is" (5 `is` "Bool") "toBeFalse";
assert "is" ("Test" `is` "List") "toBeTrue";
assert "is" ("Test" `is` "String") "toBeTrue";
assert "is" ([1] `is` "String") "toBeFalse";
assert "is" ([] `is` "String") "toBeTrue";
assert "is" (1::10) "forAll" "toBe" "Num";

someFC 20 x += 1;
someFC 30 x += 2;

assert "FClass priority" (someFC 0) "toEqual" 2;

eFC1 1 20 += \x -> [x];
assert "Explicit FClass 1 param " (eFC1 1) "toEqual" [1];

eFC2 2 20 += \x y -> [x, y];
assert "Explicit FClass 2 params" (eFC2 1 2) "toEqual" [1, 2];

eFC3 3 20 += \x y z -> [x, y, z];
assert "Explicit FClass 3 params" (eFC3 1 2 3) "toEqual" [1, 2, 3];

eFC4 4 20 += \x y z w -> [x, y, z, w];
assert "Explicit FClass 4 params" (eFC4 1 2 3 4) "toEqual" [1, 2, 3 4];


iFC1 20 x += [x];
assert "Implicit FClass 1 param " (iFC1 1) "toEqual" [1];

iFC2 20 x y += [x, y];
assert "Implicit FClass 2 params" (iFC2 1 2) "toEqual" [1, 2];

iFC3 20 x y z += [x, y, z];
assert "Implicit FClass 3 params" (iFC3 1 2 3) "toEqual" [1, 2, 3];

iFC4 20 x y z w += [x, y, z, w];
assert "Implicit FClass 4 params" (iFC4 1 2 3 4) "toEqual" [1, 2, 3 4];