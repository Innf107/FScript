-- General
id = \x -> x;
const = \x -> \y -> x;
print = \x -> put (show x);
not = \x -> if x then False else True;
eq = \x -> \y -> not (ord x y);
comp = \f -> \g -> \x -> f (g x);
° = comp;
∘ = °;
toBool = not ∘ not;
>> = comp;
flip = \f -> \x -> \y -> f y x;
|> = \x -> \f -> f x;
-- No right associativity yet
-- <| = flip |>;
-- $ = <|;
== = eq;
/= = \x -> \y -> not (x == y);
!= = /=;

-- Boolean
and = \x -> \y -> if x then y else x;
or  = \x -> \y -> if x then x else y;
&&  = and;
||  = or;
lt  = \x -> \y -> eq -1 (ord x y);
<   = lt;
gt  = \x -> \y -> eq 1 (ord x y);
>   = gt;
<=  = \x -> \y -> not (x > y);
>=  = \x -> \y -> not (x < y);


-- Math
factorial = \n -> if n
                  then (n * (factorial (n - 1)))
                  else 1;

pow = \x -> \n -> if n
    then (x * (pow x (n - 1)))
    else 1;

max = \x -> \y -> if x > y then x else y;
min = flip max;

*  = mul;
+  = add;
/  = div;
-  = sub;
^  = pow;
divBy = flip div;
subBy = flip sub;

abs = \x -> if (x < 0) then (0 - x) else x;


gcd = \x -> \y -> gcd_ (abs x) (abs y);

gcd_ = \x -> \y -> if y
    then gcd_ y (x `rem` y)
    else x;


-- Lists
map = \f -> \l -> if l then let (HT x xs) = l in
        cons (f x) (map f xs)
        else [];

mapI = \f -> \l -> mapIS f l 0;

mapIS = \f -> \l -> \i ->
        if l
        then let (HT x xs) = l in
            cons (f x i) (mapIS f xs (i + 1))
        else
            [];

flatMap = \f -> \l ->
        if l
        then let (HT x xs) = l in
            ((f x) + (flatMap f xs))
        else
            [];

<$> = map;
: = cons;

range = \s -> \e -> if (s >= e)
                    then []
                    else cons s (range (s + 1) e);

rangeStep = \s -> \e -> \step -> if (s >= e)
                                 then []
                                 else cons s (rangeStep (s + step) e step);

:: = range;

rangeI = \s -> \e -> range s (e + 1);

::+ = rangeI;


repeat = \x -> \i -> if (i <= 0)
    then []
    else (x : (repeat x (i - 1)));

filter = \f -> \l -> if l then let x = head l in let xs = tail l in
    if f x
        then cons x (filter f xs)
        else filter f xs
    else [];

foldl = \f -> \z -> \l -> if l then let x = head l in let xs = tail l in
    (foldl f (f z x) xs)
    else z;

length = \l -> if l
    then add 1 (length (tail l))
    else 0;

reverse = \l -> if l
    then let (HT x xs) = l in ((reverse xs) + [x])
    else [];

getAt = \n -> \l -> let x = head l in let xs = tail l in
    if n
        then getAt (sub n 1) xs
        else Null;
!! = getAt;

<<HT l>> head l @ tail l;

padStart = \x -> \i -> \l -> ((repeat x (i - (length l))) + l);

take = \i -> \l -> if ((toBool l) && (i > 0))
    then let (HT x xs) = l in (x : (take (i - 1) xs))
    else [];

skipLast = \i -> \l -> take ((length l) - i) l;

-- IO
>>= = compIO;

>> = \x -> \y -> x >>= (const y);

compIOForever = \a -> \f -> compIO a (\x -> compIO (f x) (\y -> compIOForever a f));

doAll = \l -> if l
    then let (HT x xs) = l in (x >> (doAll xs))
    else pureIO Null;

printAll = \l -> doAll (map print l);

putAll = \l -> doAll (map put l);

-- JSON compatibility
null = Null;
false = False;
true = True;


