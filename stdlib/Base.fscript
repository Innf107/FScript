-- General
id = \x -> x;
const = \x -> \y -> x;
print = \x -> put (show x);
printOrExec = \x -> if ((typeof x) == "IO")
    then x
    else print x;
-- printOrExec = \x -> if (ord (typeof x) "IO") then print x else x;
not = \x -> if x then False else True;
eq = \x -> \y -> not (ord x y);
comp = \f -> \g -> \x -> f (g x);
° = comp;
∘ = °;
toBool = not ∘ not;
>> = comp;
flip = \f -> \x -> \y -> f y x;
|> = \x -> \f -> f x;
-- No right associativity yet
-- <| = flip |>;
-- $ = <|;
== = eq;
/= = \x -> \y -> not (x == y);
!= = /=;

-- Boolean
and = \x -> \y -> if x then y else x;
or  = \x -> \y -> if x then x else y;
&&  = and;
||  = or;
lt  = \x -> \y -> eq -1 (ord x y);
<   = lt;
gt  = \x -> \y -> eq 1 (ord x y);
>   = gt;
<=  = \x -> \y -> not (x > y);
>=  = \x -> \y -> not (x < y);


-- Math
pi = 3.1415927;
e  = 2.7182818;

factorial = \n -> if n
                  then (n * (factorial (n - 1)))
                  else 1;

powN = \x -> \n -> if n
    then (x * (powN x (n - 1)))
    else 1;

sqrt = \x -> root 2 x;

root = \r -> \x -> rootInner r x (round (x / 2));

rootInner = \r -> \x -> \guess -> if (((abs ((powN guess r) - x)) < (0.1 * x)) || guess < 0.01)
    then guess
    else rootInner r x ((((r - 1) * guess) + (x/(powN guess (r - 1)))) / 2);

max = \x -> \y -> if x > y then x else y;
min = flip max;

* = mul;
+ = add;
/ = div;
- = sub;
^ = powN;
divBy = flip div;
subBy = flip sub;

abs = \x -> if (x < 0) then (0 - x) else x;


gcd = \x -> \y -> gcd_ (abs x) (abs y);

gcd_ = \x -> \y -> if y
    then gcd_ y (x `rem` y)
    else x;


-- Lists
mapI = \f -> \l -> mapIS f l 0;

mapIS = \f -> \l -> \i ->
        if l
        then let (HT x xs) = l in
            cons (f x i) (mapIS f xs (i + 1))
        else
            [];

flatMap = \f -> \l ->
        if l
        then let (HT x xs) = l in
            ((f x) + (flatMap f xs))
        else
            [];

<$> = map;
: = cons;

range = \s -> \e -> if (s >= e)
                    then []
                    else cons s (range (s + 1) e);

rangeStep = \s -> \e -> \step -> if (s >= e)
                                 then []
                                 else cons s (rangeStep (s + step) e step);

:: = range;

rangeI = \s -> \e -> range s (e + 1);

::+ = rangeI;


repeat = \x -> \i -> if (i <= 0)
    then []
    else (x : (repeat x (i - 1)));

filter = \f -> \l -> if l then let x = head l in let xs = tail l in
    if f x
        then cons x (filter f xs)
        else filter f xs
    else [];

foldl = \f -> \z -> \l -> if l then let x = head l in let xs = tail l in
    (foldl f (f z x) xs)
    else z;

length = \l -> if l
    then add 1 (length (tail l))
    else 0;

reverse = \l -> if l
    then let (HT x xs) = l in ((reverse xs) + [x])
    else [];

getAt = \n -> \l -> if l
    then let (HT x xs) = l in
        if n
            then getAt (sub n 1) xs
            else x
    else Null;

!! = getAt;

<<HT l>> head l @ tail l;

<<T l>> head l @ getAt 1 l @ getAt 2 l @ getAt 3 l @ getAt 4 l @ getAt 5 l @ getAt 6 l @ getAt 7 l;

padStart = \x -> \i -> \l -> ((repeat x (i - (length l))) + l);

take = \i -> \l -> if ((toBool l) && (i > 0))
    then let (HT x xs) = l in (x : (take (i - 1) xs))
    else [];

skipLast = \i -> \l -> take ((length l) - i) l;

all = \f -> foldl (\acc -> \cur -> acc && (f cur)) True;

any = \f -> foldl (\acc -> \cur -> acc || (f cur)) False;

isString = all (\x -> (typeof x) == "Char");



-- IO
>>= = compIO;

>> = \x -> \y -> x >>= (const y);

compIOForever = \a -> \f -> compIO a (\x -> compIO (f x) (\y -> compIOForever a f));

doAll = \l -> if l
    then let (HT x xs) = l in (x >> (doAll xs))
    else pureIO Null;

printAll = \l -> doAll (map print l);

putAll = \l -> doAll (map put l);

-- JSON compatibility
null = Null;
false = False;
true = True;


-- Records
update = \k -> \f -> \r -> set k (f (get k r)) r;

setAll = \s -> \x -> setAllList (entries s) x;

setAllList = \es -> \r -> if es
    then let (HT x xs) = es in let (T k v) = x in
    set k v (setAllList xs r)
    else r;

fromEntries = \es -> setAllList es {};


-- FClasses
tclass = \t -> \f -> \x -> if ((typeof x) == t)
    then f x
    else throw "Type" ("Not of type " + t);

show 0 30 += \x -> if (((typeof x) == "List") && (isString x))
    then (['"'] + (foldl (\a -> \c -> a + [c]) "" x) + ['"'])
    else throw "Type" "Not a String";


show 0 20 += tclass "List" \x -> ("[" + (showListInner x) + "]");

showListInner = \l -> if l
    then let (HT x xs) = l in if xs
        then ((show x) + ", " + (showListInner xs))
        else show x
    else "";

show 0 20 += tclass "Record" \x -> ("{" + (showRecInner (entries x)) + "}");

showRecInner = \l -> if l
    then let (HT x xs) = l in let (T k v) = x in if xs
        then ((k + ": " + (show v)) + ", " + (showRecInner xs))
        else (k + ": " + (show v))
    else "";

show 0 20 += showNum;

show 0 20 += tclass "Char" \x -> ("'" + [x] + "'");

show 0 20 += tclass "Bool" \x -> if x then "True" else "False";

show 0 20 += tclass "IO" (const "<IO>");

show 0 20 += tclass "Function" (const "<Function>");

show 0 20 += tclass "Null" (const "Null");

show 0 0 += const "<Unknown Type>";



map 1 20 += \f -> tclass "List" \l ->
    if l then let (HT x xs) = l in
                 cons (f x) (map f xs)
                 else [];

map 1 20 += \f -> tclass "Record" (\r -> fromEntries (map f (entries r)));

